// package.json
{
  "name": "mini-orders-api",
  "version": "1.0.0",
  "private": true,
  "type": "commonjs",
  "scripts": {
    "build": "nest build",
    "start": "node dist/main.js",
    "start:dev": "nest start --watch",
    "lint": "eslint . --ext .ts",
    "format": "prettier --write .",
    "test": "jest -c jest-e2e.json",
    "migrate": "prisma migrate deploy",
    "migrate:dev": "prisma migrate dev --name init",
    "prisma:generate": "prisma generate",
    "seed": "ts-node prisma/seed.ts",
    "prepare": "husky install"
  },
  "dependencies": {
    "@nestjs/common": "^10.4.5",
    "@nestjs/config": "^3.2.3",
    "@nestjs/core": "^10.4.5",
    "@nestjs/jwt": "^10.2.0",
    "@nestjs/passport": "^10.0.3",
    "@nestjs/platform-express": "^10.4.5",
    "@nestjs/throttler": "^6.2.1",
    "@prisma/client": "^5.17.0",
    "argon2": "^0.41.1",
    "class-transformer": "^0.5.1",
    "class-validator": "^0.14.1",
    "helmet": "^7.1.0",
    "passport": "^0.7.0",
    "passport-jwt": "^4.0.1",
    "reflect-metadata": "^0.2.2",
    "rxjs": "^7.8.1"
  },
  "devDependencies": {
    "@nestjs/cli": "^10.4.5",
    "@nestjs/testing": "^10.4.5",
    "@types/jest": "^29.5.12",
    "@types/node": "^20.14.10",
    "@types/supertest": "^2.0.16",
    "@typescript-eslint/eslint-plugin": "^7.16.1",
    "@typescript-eslint/parser": "^7.16.1",
    "dotenv": "^16.4.5",
    "eslint": "^8.57.0",
    "eslint-config-prettier": "^9.1.0",
    "husky": "^9.1.5",
    "jest": "^29.7.0",
    "prettier": "^3.3.3",
    "prisma": "^5.17.0",
    "supertest": "^7.0.0",
    "ts-jest": "^29.2.5",
    "ts-node": "^10.9.2",
    "typescript": "^5.5.4"
  }
}
// tsconfig.json
{
  "compilerOptions": {
    "module": "commonjs",
    "target": "ES2021",
    "outDir": "./dist",
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "strict": true,
    "sourceMap": true
  },
  "exclude": ["dist", "node_modules"]
}
// nest-cli.json
{ "collection": "@nestjs/schematics", "sourceRoot": "src" }
# .env.example
PORT=3000
DATABASE_URL=postgresql://postgres:postgres@localhost:5432/mini_orders?schema=public
JWT_ACCESS_SECRET=replace_access
JWT_REFRESH_SECRET=replace_refresh
ACCESS_TTL=900s
REFRESH_TTL=7d
// prisma/schema.prisma
generator client { provider = "prisma-client-js" }
datasource db { provider = "postgresql"; url = env("DATABASE_URL") }

model User {
  id           String   @id @default(uuid())
  email        String   @unique
  passwordHash String
  role         Role     @default(CUSTOMER)
  createdAt    DateTime @default(now())
  orders       Order[]
}

model Product {
  id          String      @id @default(uuid())
  title       String
  description String?
  priceFils   Int
  stock       Int         @default(0)
  isActive    Boolean     @default(true)
  createdAt   DateTime    @default(now())
  items       OrderItem[]
}

model Order {
  id         String       @id @default(uuid())
  user       User         @relation(fields: [userId], references: [id])
  userId     String
  status     OrderStatus  @default(PENDING)
  totalFils  Int
  createdAt  DateTime     @default(now())
  items      OrderItem[]
}

model OrderItem {
  id            String  @id @default(uuid())
  order         Order   @relation(fields: [orderId], references: [id])
  orderId       String
  product       Product @relation(fields: [productId], references: [id])
  productId     String
  qty           Int
  unitPriceFils Int
  lineTotalFils Int
}

enum Role { ADMIN CUSTOMER }
enum OrderStatus { PENDING PAID CANCELLED FULFILLED }
// prisma/seed.ts
import { PrismaClient, Role } from '@prisma/client';
import * as argon2 from 'argon2';
const prisma = new PrismaClient();
(async () => {
  await prisma.user.upsert({
    where: { email: 'admin@example.com' },
    update: {},
    create: { email: 'admin@example.com', passwordHash: await argon2.hash('Admin#123'), role: Role.ADMIN },
  });
  if ((await prisma.product.count()) === 0) {
    await prisma.product.createMany({
      data: Array.from({ length: 10 }).map((_, i) => ({
        title: `Item ${i + 1}`, description: `Demo ${i + 1}`, priceFils: 1000 * (i + 1), stock: 10 + i,
      })),
    });
  }
  process.exit(0);
})();
# Dockerfile
FROM node:20-alpine
WORKDIR /app
RUN corepack enable && corepack prepare pnpm@9.7.0 --activate
COPY package.json pnpm-lock.yaml* ./
RUN pnpm i --frozen-lockfile
COPY . .
RUN pnpm prisma:generate && pnpm build
ENV NODE_ENV=production
CMD ["node","dist/main.js"]
# docker-compose.yml
version: "3.9"
services:
  db:
    image: postgres:16-alpine
    environment:
      POSTGRES_DB: mini_orders
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
    ports: ["5432:5432"]
    volumes: [db-data:/var/lib/postgresql/data]
  app:
    build: .
    depends_on: [db]
    environment:
      DATABASE_URL: postgresql://postgres:postgres@db:5432/mini_orders?schema=public
      JWT_ACCESS_SECRET: dev_access
      JWT_REFRESH_SECRET: dev_refresh
      ACCESS_TTL: 900s
      REFRESH_TTL: 7d
      PORT: 3000
    ports: ["3000:3000"]
volumes: { db-data: {} }
// src/main.ts
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import helmet from 'helmet';
import { ValidationPipe } from '@nestjs/common';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  app.use(helmet());
  app.useGlobalPipes(new ValidationPipe({ whitelist: true, transform: true, forbidNonWhitelisted: true }));
  await app.listen(process.env.PORT || 3000);
}
bootstrap();
// src/app.module.ts
import { Module } from '@nestjs/common';
import { ConfigModule } from '@nestjs/config';
import { ThrottlerModule } from '@nestjs/throttler';
import { PrismaModule } from './prisma/prisma.module';
import { AuthModule } from './auth/auth.module';
import { ProductsModule } from './products/products.module';
import { OrdersModule } from './orders/orders.module';

@Module({
  imports: [
    ConfigModule.forRoot({ isGlobal: true }),
    ThrottlerModule.forRoot([{ ttl: 60_000, limit: 60 }]),
    PrismaModule, AuthModule, ProductsModule, OrdersModule,
  ],
})
export class AppModule {}
// src/prisma/prisma.module.ts
import { Global, Module } from '@nestjs/common';
import { PrismaService } from './prisma.service';
@Global() @Module({ providers: [PrismaService], exports: [PrismaService] }) export class PrismaModule {}
// src/prisma/prisma.service.ts
import { Injectable } from '@nestjs/common';
import { PrismaClient } from '@prisma/client';
@Injectable() export class PrismaService extends PrismaClient {}
// src/common/rbac.guard.ts
import { CanActivate, ExecutionContext, ForbiddenException, Injectable, SetMetadata } from '@nestjs/common';
import { Reflector } from '@nestjs/core';
export const Roles = (...r: ('ADMIN'|'CUSTOMER')[]) => SetMetadata('roles', r);
@Injectable()
export class RbacGuard implements CanActivate {
  constructor(private rf: Reflector) {}
  canActivate(ctx: ExecutionContext): boolean {
    const need = this.rf.getAllAndOverride<string[]>('roles', [ctx.getHandler(), ctx.getClass()]) || [];
    if (!need.length) return true;
    const user = ctx.switchToHttp().getRequest().user;
    if (!user || !need.includes(user.role)) throw new ForbiddenException({ code: 'FORBIDDEN', message: 'Insufficient role' });
    return true;
  }
}
// src/common/idempotency.interceptor.ts
import { CallHandler, ConflictException, ExecutionContext, Injectable, NestInterceptor } from '@nestjs/common';
import { Observable } from 'rxjs';
const mem = new Map<string, number>();
@Injectable()
export class IdempotencyInterceptor implements NestInterceptor {
  intercept(ctx: ExecutionContext, next: CallHandler): Observable<any> {
    const req: any = ctx.switchToHttp().getRequest();
    const key = (req.headers['idempotency-key'] || '') as string;
    const now = Date.now();
    for (const [k, t] of mem) if (now - t > 5000) mem.delete(k);
    if (key && mem.has(key)) throw new ConflictException({ code: 'IDEMPOTENT_REPLAY', message: 'Duplicate within 5s' });
    if (key) mem.set(key, now);
    return next.handle();
  }
}
// src/auth/dto.ts
import { IsEmail, IsNotEmpty, MinLength } from 'class-validator';
export class RegisterDto { @IsEmail() email!: string; @MinLength(8) password!: string; }
export class LoginDto { @IsEmail() email!: string; @IsNotEmpty() password!: string; }
// src/auth/guards.ts
import { Injectable } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';
@Injectable() export class JwtAuthGuard extends AuthGuard('jwt') {}
@Injectable() export class JwtRefreshGuard extends AuthGuard('jwt-refresh') {}
// src/auth/jwt.strategy.ts
import { Injectable } from '@nestjs/common';
import { PassportStrategy } from '@nestjs/passport';
import { ExtractJwt, Strategy } from 'passport-jwt';
import { ConfigService } from '@nestjs/config';
@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy, 'jwt') {
  constructor(cfg: ConfigService) { super({ jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(), secretOrKey: cfg.get('JWT_ACCESS_SECRET') }); }
  validate(p: any) { return p; }
}
// src/auth/jwt-refresh.strategy.ts
import { Injectable } from '@nestjs/common';
import { PassportStrategy } from '@nestjs/passport';
import { ExtractJwt, Strategy } from 'passport-jwt';
import { ConfigService } from '@nestjs/config';
@Injectable()
export class JwtRefreshStrategy extends PassportStrategy(Strategy, 'jwt-refresh') {
  constructor(cfg: ConfigService) { super({ jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(), secretOrKey: cfg.get('JWT_REFRESH_SECRET') }); }
  validate(p: any) { return p; }
}
// src/auth/auth.service.ts
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import * as argon2 from 'argon2';
import { JwtService } from '@nestjs/jwt';
import { ConfigService } from '@nestjs/config';

@Injectable()
export class AuthService {
  constructor(private prisma: PrismaService, private jwt: JwtService, private cfg: ConfigService) {}

  async register(email: string, password: string) {
    if (await this.prisma.user.findUnique({ where: { email } })) {
      throw new UnauthorizedException({ code: 'EMAIL_TAKEN', message: 'Email already registered' });
    }
    const user = await this.prisma.user.create({
      data: { email, passwordHash: await argon2.hash(password) },
      select: { id: true, email: true, role: true, createdAt: true },
    });
    return user;
  }

  async validateUser(email: string, password: string) {
    const u = await this.prisma.user.findUnique({ where: { email } });
    if (!u || !(await argon2.verify(u.passwordHash, password))) {
      throw new UnauthorizedException({ code: 'INVALID_CREDENTIALS', message: 'Invalid credentials' });
    }
    return u;
  }

  async tokens(u: { id: string; email: string; role: string }) {
    const access = await this.jwt.signAsync({ sub: u.id, email: u.email, role: u.role }, { secret: this.cfg.get('JWT_ACCESS_SECRET'), expiresIn: this.cfg.get('ACCESS_TTL') || '900s' });
    const refresh = await this.jwt.signAsync({ sub: u.id, email: u.email, role: u.role, typ: 'refresh' }, { secret: this.cfg.get('JWT_REFRESH_SECRET'), expiresIn: this.cfg.get('REFRESH_TTL') || '7d' });
    return { accessToken: access, refreshToken: refresh };
  }
}
// src/auth/auth.controller.ts
import { Body, Controller, Get, HttpCode, Post, Req, UseGuards } from '@nestjs/common';
import { Throttle } from '@nestjs/throttler';
import { AuthService } from './auth.service';
import { RegisterDto, LoginDto } from './dto';
import { JwtAuthGuard, JwtRefreshGuard } from './guards';
import { JwtService } from '@nestjs/jwt';

@Controller('auth')
export class AuthController {
  constructor(private svc: AuthService, private jwt: JwtService) {}

  @Throttle({ default: { ttl: 60_000, limit: 10 } })
  @Post('register')
  async register(@Body() dto: RegisterDto) {
    return { code: 'OK', message: 'Registered', data: await this.svc.register(dto.email, dto.password) };
  }

  @Throttle({ default: { ttl: 60_000, limit: 20 } })
  @HttpCode(200)
  @Post('login')
  async login(@Body() dto: LoginDto) {
    const u = await this.svc.validateUser(dto.email, dto.password);
    return { code: 'OK', message: 'Logged in', data: await this.svc.tokens(u) };
  }

  @UseGuards(JwtRefreshGuard)
  @Post('refresh')
  async refresh(@Req() req: any) {
    return { code: 'OK', message: 'Refreshed', data: await this.svc.tokens(req.user) };
  }

  @UseGuards(JwtAuthGuard)
  @Get('me')
  me(@Req() req: any) {
    const { sub: id, email, role } = req.user;
    return { code: 'OK', message: 'Profile', data: { id, email, role } };
  }
}
// src/auth/auth.module.ts
import { Module } from '@nestjs/common';
import { JwtModule } from '@nestjs/jwt';
import { AuthService } from './auth.service';
import { AuthController } from './auth.controller';
import { JwtStrategy } from './jwt.strategy';
import { JwtRefreshStrategy } from './jwt-refresh.strategy';
@Module({ imports: [JwtModule.register({})], controllers: [AuthController], providers: [AuthService, JwtStrategy, JwtRefreshStrategy] })
export class AuthModule {}
// src/products/dto.ts
import { IsBoolean, IsInt, IsOptional, IsPositive, IsString, Min } from 'class-validator';
export class CreateProductDto {
  @IsString() title!: string;
  @IsOptional() @IsString() description?: string;
  @IsInt() @IsPositive() priceFils!: number;
  @IsInt() @Min(0) stock!: number;
  @IsOptional() @IsBoolean() isActive?: boolean;
}
export class UpdateProductDto {
  @IsOptional() @IsString() title?: string;
  @IsOptional() @IsString() description?: string;
  @IsOptional() @IsInt() @IsPositive() priceFils?: number;
  @IsOptional() @IsInt() @Min(0) stock?: number;
  @IsOptional() @IsBoolean() isActive?: boolean;
}
// src/products/products.service.ts
import { Injectable, NotFoundException } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
@Injectable()
export class ProductsService {
  constructor(private prisma: PrismaService) {}
  create(data: any) { return this.prisma.product.create({ data }); }
  async list(page: number, limit: number, search?: string) {
    const where = search ? { OR: [{ title: { contains: search, mode: 'insensitive' } }, { description: { contains: search, mode: 'insensitive' } }] } : {};
    const [items, total] = await Promise.all([
      this.prisma.product.findMany({ where, orderBy: { createdAt: 'desc' }, skip: (page - 1) * limit, take: limit }),
      this.prisma.product.count({ where }),
    ]);
    return { items, total, page, limit };
  }
  async get(id: string) { const p = await this.prisma.product.findUnique({ where: { id } }); if (!p) throw new NotFoundException({ code: 'NOT_FOUND', message: 'Product not found' }); return p; }
  async update(id: string, data: any) { await this.get(id); return this.prisma.product.update({ where: { id }, data }); }
  async remove(id: string) { await this.get(id); await this.prisma.product.delete({ where: { id } }); return { deleted: true }; }
}
// src/products/products.controller.ts
import { Body, Controller, Delete, Get, Param, Patch, Post, Query, UseGuards } from '@nestjs/common';
import { ProductsService } from './products.service';
import { CreateProductDto, UpdateProductDto } from './dto';
import { JwtAuthGuard } from '../auth/guards';
import { RbacGuard, Roles } from '../common/rbac.guard';

@Controller('products')
export class ProductsController {
  constructor(private svc: ProductsService) {}
  @UseGuards(JwtAuthGuard, RbacGuard) @Roles('ADMIN') @Post() async create(@Body() dto: CreateProductDto) {
    return { code: 'OK', message: 'Created', data: await this.svc.create(dto) };
  }
  @Get() async list(@Query('page') page = '1', @Query('limit') limit = '20', @Query('search') search?: string) {
    const p = Math.max(parseInt(page, 10) || 1, 1); const l = Math.min(Math.max(parseInt(limit, 10) || 20, 1), 100);
    return { code: 'OK', message: 'List', data: await this.svc.list(p, l, search) };
  }
  @Get(':id') async get(@Param('id') id: string) { return { code: 'OK', message: 'Product', data: await this.svc.get(id) }; }
  @UseGuards(JwtAuthGuard, RbacGuard) @Roles('ADMIN') @Patch(':id') async update(@Param('id') id: string, @Body() dto: UpdateProductDto) {
    return { code: 'OK', message: 'Updated', data: await this.svc.update(id, dto) };
  }
  @UseGuards(JwtAuthGuard, RbacGuard) @Roles('ADMIN') @Delete(':id') async remove(@Param('id') id: string) {
    return { code: 'OK', message: 'Deleted', data: await this.svc.remove(id) };
  }
}
// src/products/products.module.ts
import { Module } from '@nestjs/common';
import { ProductsController } from './products.controller';
import { ProductsService } from './products.service';
@Module({ controllers: [ProductsController], providers: [ProductsService] }) export class ProductsModule {}
// src/orders/dto.ts
import { ArrayNotEmpty, IsArray, IsInt, IsUUID, Min, ValidateNested, IsIn } from 'class-validator';
import { Type } from 'class-transformer';
export class OrderItemInput { @IsUUID() productId!: string; @IsInt() @Min(1) qty!: number; }
export class CreateOrderDto { @IsArray() @ArrayNotEmpty() @ValidateNested({ each: true }) @Type(() => OrderItemInput) items!: OrderItemInput[]; }
export class UpdateOrderStatusDto { @IsIn(['PENDING','PAID','CANCELLED','FULFILLED']) status!: 'PENDING'|'PAID'|'CANCELLED'|'FULFILLED'; }
// src/orders/orders.service.ts
import { BadRequestException, Injectable, NotFoundException } from '@nestjs/common';
import { PrismaService } from '../prisma/prisma.service';
import { OrderStatus } from '@prisma/client';

@Injectable()
export class OrdersService {
  constructor(private prisma: PrismaService) {}

  async create(userId: string, items: { productId: string; qty: number }[]) {
    const ids = [...new Set(items.map(i => i.productId))];
    const products = await this.prisma.product.findMany({ where: { id: { in: ids }, isActive: true } });
    if (products.length !== ids.length) throw new BadRequestException({ code:'INVALID_ITEMS', message:'Some products not found/active' });
    const enriched = items.map(i => {
      const p = products.find(pp => pp.id === i.productId)!;
      if (i.qty <= 0) throw new BadRequestException({ code:'INVALID_QTY', message:'qty must be > 0' });
      if (p.stock < i.qty) throw new BadRequestException({ code:'INSUFFICIENT_STOCK', message:`Insufficient stock for ${p.title}` });
      return { p, qty: i.qty };
    });
    const total = enriched.reduce((s, it) => s + it.p.priceFils * it.qty, 0);

    return this.prisma.$transaction(async tx => {
      for (const it of enriched) await tx.product.update({ where: { id: it.p.id, stock: { gte: it.qty } }, data: { stock: { decrement: it.qty } } });
      return tx.order.create({
        data: {
          userId, status: OrderStatus.PENDING, totalFils: total,
          items: { create: enriched.map(it => ({ productId: it.p.id, qty: it.qty, unitPriceFils: it.p.priceFils, lineTotalFils: it.p.priceFils * it.qty })) },
        },
        include: { items: true },
      });
    });
  }

  async list(user: { id: string; role: string }, status?: OrderStatus, page=1, limit=20) {
    const where: any = { ...(status ? { status } : {}) };
    if (user.role !== 'ADMIN') where.userId = user.id;
    const [items, total] = await Promise.all([
      this.prisma.order.findMany({ where, orderBy: { createdAt: 'desc' }, skip: (page-1)*limit, take: limit, include: { items: true } }),
      this.prisma.order.count({ where }),
    ]);
    return { items, total, page, limit };
  }

  async get(user: { id: string; role: string }, id: string) {
    const o = await this.prisma.order.findUnique({ where: { id }, include: { items: true } });
    if (!o || (user.role !== 'ADMIN' && o.userId !== user.id)) throw new NotFoundException({ code:'NOT_FOUND', message:'Order not found' });
    return o;
  }

  async setStatus(id: string, status: OrderStatus) {
    if (!(await this.prisma.order.findUnique({ where: { id } }))) throw new NotFoundException({ code:'NOT_FOUND', message:'Order not found' });
    return this.prisma.order.update({ where: { id }, data: { status } });
  }
}
// src/orders/orders.controller.ts
import { Body, Controller, Get, Param, Patch, Post, Query, Req, UseGuards, UseInterceptors } from '@nestjs/common';
import { OrdersService } from './orders.service';
import { CreateOrderDto, UpdateOrderStatusDto } from './dto';
import { JwtAuthGuard } from '../auth/guards';
import { RbacGuard, Roles } from '../common/rbac.guard';
import { IdempotencyInterceptor } from '../common/idempotency.interceptor';

@UseGuards(JwtAuthGuard)
@Controller('orders')
export class OrdersController {
  constructor(private svc: OrdersService) {}

  @UseInterceptors(IdempotencyInterceptor)
  @Post()
  async create(@Req() req: any, @Body() dto: CreateOrderDto) {
    return { code: 'OK', message: 'Order created', data: await this.svc.create(req.user.sub, dto.items) };
  }

  @Get()
  async list(@Req() req: any, @Query('status') status?: any, @Query('page') page='1', @Query('limit') limit='20') {
    const p = Math.max(parseInt(page,10)||1,1), l = Math.min(Math.max(parseInt(limit,10)||20,1),100);
    return { code: 'OK', message: 'Orders', data: await this.svc.list(req.user, status, p, l) };
  }

  @Get(':id')
  async get(@Req() req: any, @Param('id') id: string) {
    return { code: 'OK', message: 'Order', data: await this.svc.get(req.user, id) };
  }

  @UseGuards(RbacGuard) @Roles('ADMIN')
  @Patch(':id/status')
  async status(@Param('id') id: string, @Body() dto: UpdateOrderStatusDto) {
    return { code: 'OK', message: 'Status updated', data: await this.svc.setStatus(id, dto.status as any) };
  }
}
// src/orders/orders.module.ts
import { Module } from '@nestjs/common';
import { OrdersController } from './orders.controller';
import { OrdersService } from './orders.service';
@Module({ controllers: [OrdersController], providers: [OrdersService] }) export class OrdersModule {}
// test/setup.ts
import 'dotenv/config';
process.env.DATABASE_URL ||= 'postgresql://postgres:postgres@localhost:5432/mini_orders?schema=public';
process.env.JWT_ACCESS_SECRET ||= 'test_access';
process.env.JWT_REFRESH_SECRET ||= 'test_refresh';
// jest-e2e.json
{
  "testEnvironment": "node",
  "rootDir": ".",
  "testRegex": ".e2e-spec.ts$",
  "moduleFileExtensions": ["ts", "js", "json"],
  "transform": { "^.+\\.(t|j)s$": "ts-jest" },
  "setupFiles": ["<rootDir>/test/setup.ts"]
}
// test/utils.ts
import { INestApplication, ValidationPipe } from '@nestjs/common';
import { Test } from '@nestjs/testing';
import { AppModule } from '../src/app.module';
import helmet from 'helmet';
import { PrismaService } from '../src/prisma/prisma.service';

export async function createApp() {
  const m = await Test.createTestingModule({ imports: [AppModule] }).compile();
  const app: INestApplication = m.createNestApplication();
  app.use(helmet());
  app.useGlobalPipes(new ValidationPipe({ whitelist: true, transform: true }));
  await app.init();
  const prisma = app.get(PrismaService);
  await prisma.$executeRawUnsafe(`TRUNCATE "OrderItem","Order","Product","User" RESTART IDENTITY CASCADE`);
  return { app, prisma };
}
// test/auth.e2e-spec.ts
import request from 'supertest';
import { createApp } from './utils';

describe('Auth', () => {
  let app: any;
  beforeAll(async () => { app = (await createApp()).app; });
  afterAll(async () => { await app.close(); });

  it('register/login/refresh', async () => {
    await request(app.getHttpServer()).post('/auth/register').send({ email: 'u@e.com', password: 'Password#1' }).expect(201);
    const login = await request(app.getHttpServer()).post('/auth/login').send({ email: 'u@e.com', password: 'Password#1' }).expect(200);
    const refresh = await request(app.getHttpServer()).post('/auth/refresh').set('Authorization', `Bearer ${login.body.data.refreshToken}`).expect(201);
    expect(refresh.body.data.accessToken).toBeDefined();
  });

  it('invalid creds', async () => {
    await request(app.getHttpServer()).post('/auth/login').send({ email: 'x@e.com', password: 'bad' }).expect(401);
  });
});
// test/products.e2e-spec.ts
import request from 'supertest';
import { createApp } from './utils';
import { PrismaClient, Role } from '@prisma/client';
import * as argon2 from 'argon2';

describe('Products', () => {
  let app: any; let prisma: PrismaClient; let adminToken: string; let customerToken: string;
  beforeAll(async () => {
    const { app: a, prisma: p } = await createApp(); app = a; prisma = p as any;
    await prisma.user.createMany({
      data: [
        { email: 'admin@p.com', passwordHash: await argon2.hash('Admin#123'), role: Role.ADMIN },
        { email: 'c@p.com', passwordHash: await argon2.hash('Customer#123'), role: Role.CUSTOMER },
      ],
    });
    adminToken = (await request(app.getHttpServer()).post('/auth/login').send({ email: 'admin@p.com', password: 'Admin#123' })).body.data.accessToken;
    customerToken = (await request(app.getHttpServer()).post('/auth/login').send({ email: 'c@p.com', password: 'Customer#123' })).body.data.accessToken;
  });
  afterAll(async () => { await app.close(); });

  it('admin-only create', async () => {
    const body = { title: 'P1', priceFils: 1000, stock: 5 };
    await request(app.getHttpServer()).post('/products').set('Authorization', `Bearer ${adminToken}`).send(body).expect(201);
    await request(app.getHttpServer()).post('/products').set('Authorization', `Bearer ${customerToken}`).send(body).expect(403);
  });

  it('list pagination', async () => {
    for (let i = 0; i < 25; i++) await prisma.product.create({ data: { title: `Item ${i}`, priceFils: 1000+i, stock: 10 } });
    const res = await request(app.getHttpServer()).get('/products?page=2&limit=10').expect(200);
    expect(res.body.data.items.length).toBe(10);
  });
});
// test/orders.e2e-spec.ts
import request from 'supertest';
import { createApp } from './utils';
import { PrismaClient, Role } from '@prisma/client';
import * as argon2 from 'argon2';

describe('Orders', () => {
  let app: any; let prisma: PrismaClient; let adminToken: string; let customerToken: string; let productId: string;
  beforeAll(async () => {
    const { app: a, prisma: p } = await createApp(); app = a; prisma = p as any;
    await prisma.user.createMany({
      data: [
        { email: 'a@x.com', passwordHash: await argon2.hash('Admin#123'), role: Role.ADMIN },
        { email: 'c@x.com', passwordHash: await argon2.hash('Customer#123'), role: Role.CUSTOMER },
      ],
    });
    adminToken = (await request(app.getHttpServer()).post('/auth/login').send({ email: 'a@x.com', password: 'Admin#123' })).body.data.accessToken;
    customerToken = (await request(app.getHttpServer()).post('/auth/login').send({ email: 'c@x.com', password: 'Customer#123' })).body.data.accessToken;
    productId = (await prisma.product.create({ data: { title: 'Phone', priceFils: 50000, stock: 3 } })).id;
  });
  afterAll(async () => { await app.close(); });

  it('create order (stock decrements) + idempotency', async () => {
    const body = { items: [{ productId, qty: 2 }] };
    const key = 'abc123';
    await request(app.getHttpServer()).post('/orders').set('Authorization', `Bearer ${customerToken}`).set('Idempotency-Key', key).send(body).expect(201);
    await request(app.getHttpServer()).post('/orders').set('Authorization', `Bearer ${customerToken}`).set('Idempotency-Key', key).send(body).expect(409);
    expect((await prisma.product.findUnique({ where: { id: productId } }))!.stock).toBe(1);
  });

  it('get own orders; admin can update status; validation negative qty fails', async () => {
    const srv = app.getHttpServer();
    const my = await request(srv).get('/orders').set('Authorization', `Bearer ${customerToken}`).expect(200);
    const all = await request(srv).get('/orders').set('Authorization', `Bearer ${adminToken}`).expect(200);
    const orderId = all.body.data.items[0].id;
    await request(srv).patch(`/orders/${orderId}/status`).set('Authorization', `Bearer ${adminToken}`).send({ status: 'PAID' }).expect(200);
    await request(srv).post('/orders').set('Authorization', `Bearer ${customerToken}`).send({ items: [{ productId, qty: -1 }] }).expect(400);
    expect(my.body.data.items.length).toBeGreaterThan(0);
  });
});
// .github/workflows/ci.yml
name: CI
on: [push, pull_request]
jobs:
  test:
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:16-alpine
        env: { POSTGRES_USER: postgres, POSTGRES_PASSWORD: postgres, POSTGRES_DB: mini_orders }
        ports: ['5432:5432']
        options: >-
          --health-cmd="pg_isready -U postgres" --health-interval=10s
          --health-timeout=5s --health-retries=5
    env:
      DATABASE_URL: postgresql://postgres:postgres@localhost:5432/mini_orders?schema=public
      JWT_ACCESS_SECRET: test_access
      JWT_REFRESH_SECRET: test_refresh
      ACCESS_TTL: 900s
      REFRESH_TTL: 7d
    steps:
      - uses: actions/checkout@v4
      - uses: pnpm/action-setup@v4
        with: { version: 9.7.0 }
      - uses: actions/setup-node@v4
        with: { node-version: 20, cache: 'pnpm' }
      - run: pnpm i --frozen-lockfile
      - run: pnpm prisma:generate
      - run: pnpm migrate:dev
      - run: pnpm test
// .eslintrc.js
module.exports = { parser: '@typescript-eslint/parser', plugins: ['@typescript-eslint'], extends: ['plugin:@typescript-eslint/recommended','prettier'] };
// .prettierrc
{ "singleQuote": true, "semi": true }
